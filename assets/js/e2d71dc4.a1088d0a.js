"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[7075],{6315:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});const l=JSON.parse('{"id":"module-3/motion-planning","title":"Motion Planning for Robots","description":"Introduction","source":"@site/docs/module-3/motion-planning.md","sourceDirName":"module-3","slug":"/module-3/motion-planning","permalink":"/GIAIC-HACKATON-1-PROJECT-1/docs/module-3/motion-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-3/motion-planning.md","tags":[],"version":"current","frontMatter":{"title":"Motion Planning for Robots","week":9,"module":3},"sidebar":"tutorialSidebar","previous":{"title":"NVIDIA Isaac Sim","permalink":"/GIAIC-HACKATON-1-PROJECT-1/docs/module-3/nvidia-isaac-sim"},"next":{"title":"Overview","permalink":"/GIAIC-HACKATON-1-PROJECT-1/docs/module-3-isaac/"}}');var r=i(4848),s=i(8453);const o={title:"Motion Planning for Robots",week:9,module:3},t="Motion Planning for Robots",a={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Problem Formulation",id:"problem-formulation",level:2},{value:"Configuration Space (C-space)",id:"configuration-space-c-space",level:3},{value:"Planning Problem",id:"planning-problem",level:3},{value:"Planning Algorithms",id:"planning-algorithms",level:2},{value:"Graph-Based Methods",id:"graph-based-methods",level:3},{value:"Sampling-Based Methods",id:"sampling-based-methods",level:3},{value:"Potential Field Methods",id:"potential-field-methods",level:3},{value:"Optimization-Based Planning",id:"optimization-based-planning",level:2},{value:"Trajectory Optimization",id:"trajectory-optimization",level:3},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:3},{value:"Planning for Different Robot Types",id:"planning-for-different-robot-types",level:2},{value:"Mobile Robots",id:"mobile-robots",level:3},{value:"Manipulators",id:"manipulators",level:3},{value:"Legged Robots",id:"legged-robots",level:3},{value:"Aerial Robots",id:"aerial-robots",level:3},{value:"Collision Detection",id:"collision-detection",level:2},{value:"Geometric Primitives",id:"geometric-primitives",level:3},{value:"Collision Checking Libraries",id:"collision-checking-libraries",level:3},{value:"Path Smoothing and Post-Processing",id:"path-smoothing-and-post-processing",level:2},{value:"Shortcutting",id:"shortcutting",level:3},{value:"B-Spline Smoothing",id:"b-spline-smoothing",level:3},{value:"Velocity Profile Generation",id:"velocity-profile-generation",level:3},{value:"ROS 2 Integration",id:"ros-2-integration",level:2},{value:"MoveIt 2",id:"moveit-2",level:3},{value:"Nav2",id:"nav2",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Multi-Robot Planning",id:"multi-robot-planning",level:3},{value:"Learning-Based Planning",id:"learning-based-planning",level:3},{value:"Real-Time Replanning",id:"real-time-replanning",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Resources",id:"resources",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"motion-planning-for-robots",children:"Motion Planning for Robots"})}),"\n",(0,r.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(e.p,{children:"Motion planning is the process of finding a collision-free path for a robot to move from a start configuration to a goal configuration. It's a fundamental problem in robotics that combines geometry, kinematics, and optimization."}),"\n",(0,r.jsx)(e.h2,{id:"problem-formulation",children:"Problem Formulation"}),"\n",(0,r.jsx)(e.h3,{id:"configuration-space-c-space",children:"Configuration Space (C-space)"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Configuration"}),": Complete specification of robot's pose"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Degrees of Freedom (DOF)"}),": Number of independent parameters"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"C-space"}),": Set of all possible configurations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"C-obstacles"}),": Regions in C-space representing collisions"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"planning-problem",children:"Planning Problem"}),"\n",(0,r.jsx)(e.p,{children:"Given:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Start configuration q_start"}),"\n",(0,r.jsx)(e.li,{children:"Goal configuration q_goal"}),"\n",(0,r.jsx)(e.li,{children:"Obstacles in environment"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Find:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Collision-free path from q_start to q_goal"}),"\n",(0,r.jsx)(e.li,{children:"Optionally: Optimize for path length, smoothness, or time"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"planning-algorithms",children:"Planning Algorithms"}),"\n",(0,r.jsx)(e.h3,{id:"graph-based-methods",children:"Graph-Based Methods"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsxs)(e.em,{children:[(0,r.jsx)(e.em,{children:"A"})," Algorithm"]}),"*"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Finds optimal path on a graph"}),"\n",(0,r.jsx)(e.li,{children:"Uses heuristic to guide search"}),"\n",(0,r.jsx)(e.li,{children:"Complete and optimal"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import heapq\r\n\r\ndef astar(start, goal, graph, heuristic):\r\n    open_set = [(0, start)]\r\n    came_from = {}\r\n    g_score = {start: 0}\r\n    f_score = {start: heuristic(start, goal)}\r\n\r\n    while open_set:\r\n        current = heapq.heappop(open_set)[1]\r\n\r\n        if current == goal:\r\n            return reconstruct_path(came_from, current)\r\n\r\n        for neighbor in graph.neighbors(current):\r\n            tentative_g = g_score[current] + graph.cost(current, neighbor)\r\n\r\n            if neighbor not in g_score or tentative_g < g_score[neighbor]:\r\n                came_from[neighbor] = current\r\n                g_score[neighbor] = tentative_g\r\n                f_score[neighbor] = tentative_g + heuristic(neighbor, goal)\r\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\r\n\r\n    return None  # No path found\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Dijkstra's Algorithm"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"A* without heuristic"}),"\n",(0,r.jsx)(e.li,{children:"Guaranteed shortest path"}),"\n",(0,r.jsx)(e.li,{children:"Explores all directions equally"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsxs)(e.em,{children:[(0,r.jsx)(e.em,{children:"D"})," (Dynamic A"]}),")**"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Replans efficiently when obstacles change"}),"\n",(0,r.jsx)(e.li,{children:"Used in dynamic environments"}),"\n",(0,r.jsx)(e.li,{children:"Incremental search"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"sampling-based-methods",children:"Sampling-Based Methods"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"RRT (Rapidly-exploring Random Tree)"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Probabilistically complete"}),"\n",(0,r.jsx)(e.li,{children:"Fast for high-dimensional spaces"}),"\n",(0,r.jsx)(e.li,{children:"Builds tree by random sampling"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import numpy as np\r\n\r\nclass RRT:\r\n    def __init__(self, start, goal, obstacles, bounds, step_size=0.5):\r\n        self.start = start\r\n        self.goal = goal\r\n        self.obstacles = obstacles\r\n        self.bounds = bounds\r\n        self.step_size = step_size\r\n        self.tree = {tuple(start): None}\r\n\r\n    def plan(self, max_iterations=10000):\r\n        for _ in range(max_iterations):\r\n            # Sample random configuration\r\n            if np.random.rand() < 0.1:  # Goal bias\r\n                q_rand = self.goal\r\n            else:\r\n                q_rand = self.sample_free()\r\n\r\n            # Find nearest node in tree\r\n            q_near = self.nearest(q_rand)\r\n\r\n            # Extend towards random sample\r\n            q_new = self.steer(q_near, q_rand)\r\n\r\n            # Check collision\r\n            if not self.collision_free(q_near, q_new):\r\n                continue\r\n\r\n            # Add to tree\r\n            self.tree[tuple(q_new)] = tuple(q_near)\r\n\r\n            # Check if goal reached\r\n            if np.linalg.norm(q_new - self.goal) < self.step_size:\r\n                self.tree[tuple(self.goal)] = tuple(q_new)\r\n                return self.extract_path()\r\n\r\n        return None  # No path found\r\n\r\n    def sample_free(self):\r\n        while True:\r\n            q = np.random.uniform(self.bounds[0], self.bounds[1])\r\n            if not self.in_collision(q):\r\n                return q\r\n\r\n    def nearest(self, q):\r\n        distances = [np.linalg.norm(np.array(node) - q) for node in self.tree]\r\n        return np.array(list(self.tree.keys())[np.argmin(distances)])\r\n\r\n    def steer(self, q_near, q_rand):\r\n        direction = q_rand - q_near\r\n        length = np.linalg.norm(direction)\r\n        if length > self.step_size:\r\n            return q_near + (direction / length) * self.step_size\r\n        return q_rand\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"RRT"}),"*"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Asymptotically optimal version of RRT"}),"\n",(0,r.jsx)(e.li,{children:"Rewires tree to improve paths"}),"\n",(0,r.jsx)(e.li,{children:"Converges to optimal solution"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"PRM (Probabilistic Roadmap)"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Builds roadmap in preprocessing"}),"\n",(0,r.jsx)(e.li,{children:"Query phase finds path on roadmap"}),"\n",(0,r.jsx)(e.li,{children:"Good for multi-query scenarios"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"potential-field-methods",children:"Potential Field Methods"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Artificial Potential Fields"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Attractive potential towards goal"}),"\n",(0,r.jsx)(e.li,{children:"Repulsive potential from obstacles"}),"\n",(0,r.jsx)(e.li,{children:"Robot moves along negative gradient"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Advantages"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Simple and fast"}),"\n",(0,r.jsx)(e.li,{children:"Real-time computation"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Disadvantages"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Local minima problems"}),"\n",(0,r.jsx)(e.li,{children:"Oscillations in narrow passages"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"optimization-based-planning",children:"Optimization-Based Planning"}),"\n",(0,r.jsx)(e.h3,{id:"trajectory-optimization",children:"Trajectory Optimization"}),"\n",(0,r.jsx)(e.p,{children:"Find trajectory that minimizes cost while satisfying constraints:"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Cost Function"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Smoothness (minimize jerk)"}),"\n",(0,r.jsx)(e.li,{children:"Energy consumption"}),"\n",(0,r.jsx)(e.li,{children:"Execution time"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Constraints"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Collision avoidance"}),"\n",(0,r.jsx)(e.li,{children:"Joint limits"}),"\n",(0,r.jsx)(e.li,{children:"Velocity/acceleration limits"}),"\n",(0,r.jsx)(e.li,{children:"Dynamic feasibility"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Optimize over finite horizon"}),"\n",(0,r.jsx)(e.li,{children:"Execute first action"}),"\n",(0,r.jsx)(e.li,{children:"Replan at each time step"}),"\n",(0,r.jsx)(e.li,{children:"Handles constraints explicitly"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import casadi as ca\r\n\r\ndef mpc_trajectory(x0, goal, obstacles, horizon=10):\r\n    # Decision variables\r\n    x = ca.SX.sym('x', horizon+1, 2)  # States\r\n    u = ca.SX.sym('u', horizon, 2)    # Controls\r\n\r\n    # Cost function\r\n    cost = 0\r\n    for k in range(horizon):\r\n        # State cost (distance to goal)\r\n        cost += ca.norm_2(x[k+1] - goal)**2\r\n\r\n        # Control effort\r\n        cost += 0.1 * ca.norm_2(u[k])**2\r\n\r\n    # Dynamics constraints\r\n    constraints = []\r\n    for k in range(horizon):\r\n        constraints.append(x[k+1] == x[k] + u[k])  # Simple integrator\r\n\r\n    # Obstacle avoidance\r\n    for k in range(horizon+1):\r\n        for obs in obstacles:\r\n            constraints.append(ca.norm_2(x[k] - obs['center']) >= obs['radius'])\r\n\r\n    # Solve optimization\r\n    nlp = {'x': ca.vertcat(ca.reshape(x, -1, 1), ca.reshape(u, -1, 1)),\r\n           'f': cost,\r\n           'g': ca.vertcat(*constraints)}\r\n\r\n    solver = ca.nlpsol('solver', 'ipopt', nlp)\r\n    solution = solver(x0=initial_guess, lbg=0, ubg=0)\r\n\r\n    return solution['x']\n"})}),"\n",(0,r.jsx)(e.h2,{id:"planning-for-different-robot-types",children:"Planning for Different Robot Types"}),"\n",(0,r.jsx)(e.h3,{id:"mobile-robots",children:"Mobile Robots"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"2D or 3D navigation"}),"\n",(0,r.jsx)(e.li,{children:"Holonomic vs. non-holonomic constraints"}),"\n",(0,r.jsx)(e.li,{children:"Grid-based or continuous planning"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"manipulators",children:"Manipulators"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"High-dimensional configuration space (6-7 DOF)"}),"\n",(0,r.jsx)(e.li,{children:"Joint limits and singularities"}),"\n",(0,r.jsx)(e.li,{children:"Inverse kinematics"}),"\n",(0,r.jsx)(e.li,{children:"Collision checking with environment and self"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"legged-robots",children:"Legged Robots"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Footstep planning"}),"\n",(0,r.jsx)(e.li,{children:"Center of mass trajectory"}),"\n",(0,r.jsx)(e.li,{children:"Contact constraints"}),"\n",(0,r.jsx)(e.li,{children:"Dynamic stability"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"aerial-robots",children:"Aerial Robots"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"3D path planning"}),"\n",(0,r.jsx)(e.li,{children:"Minimum snap trajectories"}),"\n",(0,r.jsx)(e.li,{children:"Wind disturbance consideration"}),"\n",(0,r.jsx)(e.li,{children:"Obstacle avoidance with safety margins"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"collision-detection",children:"Collision Detection"}),"\n",(0,r.jsx)(e.h3,{id:"geometric-primitives",children:"Geometric Primitives"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Bounding boxes (AABB, OBB)"}),"\n",(0,r.jsx)(e.li,{children:"Spheres and cylinders"}),"\n",(0,r.jsx)(e.li,{children:"Convex hulls"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"collision-checking-libraries",children:"Collision Checking Libraries"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"FCL (Flexible Collision Library)"}),"\n",(0,r.jsx)(e.li,{children:"Bullet Physics"}),"\n",(0,r.jsx)(e.li,{children:"Drake collision engine"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# Example with FCL\r\nimport fcl\r\n\r\n# Create collision objects\r\nmesh1 = fcl.BVHModel()\r\nmesh1.beginModel()\r\nmesh1.addSubModel(vertices1, triangles1)\r\nmesh1.endModel()\r\n\r\nobj1 = fcl.CollisionObject(mesh1, transform1)\r\nobj2 = fcl.CollisionObject(mesh2, transform2)\r\n\r\n# Check collision\r\nrequest = fcl.CollisionRequest()\r\nresult = fcl.CollisionResult()\r\nfcl.collide(obj1, obj2, request, result)\r\n\r\nis_collision = result.is_collision()\n"})}),"\n",(0,r.jsx)(e.h2,{id:"path-smoothing-and-post-processing",children:"Path Smoothing and Post-Processing"}),"\n",(0,r.jsx)(e.h3,{id:"shortcutting",children:"Shortcutting"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Connect non-adjacent waypoints if collision-free"}),"\n",(0,r.jsx)(e.li,{children:"Iterative improvement"}),"\n",(0,r.jsx)(e.li,{children:"Reduces path length"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"b-spline-smoothing",children:"B-Spline Smoothing"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Fit smooth curve through waypoints"}),"\n",(0,r.jsx)(e.li,{children:"Control smoothness vs. deviation"}),"\n",(0,r.jsx)(e.li,{children:"Continuous derivatives"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"velocity-profile-generation",children:"Velocity Profile Generation"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Respect velocity and acceleration limits"}),"\n",(0,r.jsx)(e.li,{children:"Trapezoidal or S-curve profiles"}),"\n",(0,r.jsx)(e.li,{children:"Time-optimal trajectories"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n",(0,r.jsx)(e.h3,{id:"moveit-2",children:"MoveIt 2"}),"\n",(0,r.jsx)(e.p,{children:"Motion planning framework for manipulators:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'from moveit_py import MoveItPy\r\n\r\n# Initialize MoveIt\r\nmoveit = MoveItPy(node_name="moveit_py")\r\nrobot = moveit.get_robot_model()\r\nplanning_scene = moveit.get_planning_scene_monitor().planning_scene\r\n\r\n# Plan to pose\r\narm = moveit.get_planning_component("arm")\r\narm.set_goal_state(target_pose)\r\n\r\n# Plan\r\nplan_result = arm.plan()\r\n\r\nif plan_result:\r\n    # Execute\r\n    arm.execute(plan_result.trajectory)\n'})}),"\n",(0,r.jsx)(e.h3,{id:"nav2",children:"Nav2"}),"\n",(0,r.jsx)(e.p,{children:"Navigation stack for mobile robots:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"AMCL: Adaptive Monte Carlo Localization"}),"\n",(0,r.jsx)(e.li,{children:"Global planner: A*, NavFn, Theta*"}),"\n",(0,r.jsx)(e.li,{children:"Local planner: DWA, TEB, MPPI"}),"\n",(0,r.jsx)(e.li,{children:"Recovery behaviors"}),"\n",(0,r.jsx)(e.li,{children:"Costmaps for obstacle representation"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,r.jsx)(e.h3,{id:"multi-robot-planning",children:"Multi-Robot Planning"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Centralized vs. decentralized"}),"\n",(0,r.jsx)(e.li,{children:"Priority-based planning"}),"\n",(0,r.jsx)(e.li,{children:"Velocity obstacles"}),"\n",(0,r.jsx)(e.li,{children:"Reciprocal collision avoidance"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"learning-based-planning",children:"Learning-Based Planning"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Neural network policies"}),"\n",(0,r.jsx)(e.li,{children:"Reinforcement learning"}),"\n",(0,r.jsx)(e.li,{children:"Imitation learning from demonstrations"}),"\n",(0,r.jsx)(e.li,{children:"Combining classical and learned approaches"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"real-time-replanning",children:"Real-Time Replanning"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Dynamic environments"}),"\n",(0,r.jsx)(e.li,{children:"Moving obstacles"}),"\n",(0,r.jsx)(e.li,{children:"Anytime algorithms"}),"\n",(0,r.jsx)(e.li,{children:"Safe corridor generation"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Choose Right Algorithm"}),": Match algorithm to problem characteristics"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Tune Parameters"}),": Adjust step size, goal bias, collision margins"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Hierarchical Planning"}),": Global path + local refinement"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Validate Plans"}),": Check for dynamic feasibility"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Graceful Degradation"}),": Have fallback behaviors"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Benchmarking"}),": Test on diverse scenarios"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Ignoring Dynamics"}),": Kinematically feasible but dynamically infeasible"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Insufficient Collision Margin"}),": Paths too close to obstacles"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Poor Heuristics"}),": Slow A* convergence"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Local Minima"}),": Potential fields getting stuck"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Over-Smoothing"}),": Loss of obstacle clearance"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"resources",children:"Resources"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"OMPL (Open Motion Planning Library): ompl.kavrakilab.org"}),"\n",(0,r.jsx)(e.li,{children:"MoveIt 2 Documentation: moveit.ros.org"}),"\n",(0,r.jsx)(e.li,{children:"Nav2 Documentation: navigation.ros.org"}),"\n",(0,r.jsx)(e.li,{children:"Planning Algorithms Book: lavalle.pl/planning"}),"\n",(0,r.jsx)(e.li,{children:"Robotics: Modelling, Planning and Control (Siciliano)"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>t});var l=i(6540);const r={},s=l.createContext(r);function o(n){const e=l.useContext(s);return l.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),l.createElement(s.Provider,{value:e},n.children)}}}]);