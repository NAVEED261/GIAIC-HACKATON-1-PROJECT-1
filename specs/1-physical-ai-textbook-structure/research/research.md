# Research: Physical AI Textbook Structure

**Date:** 2025-12-09
**Feature:** Physical AI Textbook Structure
**Status:** Complete

## Purpose

This document consolidates research findings for implementing the Physical AI textbook structure using Docusaurus v3, including best practices for documentation sites, custom component patterns, metadata validation, and search integration.

## Research Topics

### 1. Docusaurus v3 Best Practices for Large Documentation Sites

**Question:** How to structure a Docusaurus site with 40-50 pages across 13 weeks while maintaining navigation usability?

**Decision:** Use nested sidebar categories with auto-collapse feature

**Rationale:**
- Docusaurus v3 supports deeply nested sidebars with collapsible categories
- `collapsed: true` option allows hiding non-active modules to reduce visual clutter
- Auto-generated sidebars from directory structure reduce manual configuration burden
- Breadcrumbs and TOC provide additional navigation context

**Alternatives Considered:**
1. **Flat sidebar with manual grouping:** Rejected - becomes unwieldy with 40+ items
2. **Multiple sidebars with tab switching:** Rejected - harder to see prerequisite chains across modules
3. **Custom navigation tree component:** Rejected - unnecessary complexity, Docusaurus built-in features sufficient

**Implementation Guidance:**
```javascript
// sidebars.ts - Use autogenerated sidebars with metadata
module.exports = {
  tutorialSidebar: [
    {
      type: 'autogenerated',
      dirName: 'docs',
    },
  ],
};

// Alternative: Use explicit sidebar with collapse control
{
  type: 'category',
  label: 'Module 1: ROS 2 (Weeks 3-5)',
  collapsed: true,  // Collapse by default
  collapsible: true,  // Allow users to expand/collapse
  items: ['module-1-ros2/index', /* ... */],
}
```

**References:**
- [Docusaurus Sidebar Documentation](https://docusaurus.io/docs/sidebar)
- [Managing Large Documentation Sites with Docusaurus](https://docusaurus.io/blog/2021/11/21/algolia-docsearch-migration)

---

### 2. Custom React Components in Docusaurus

**Question:** Best patterns for creating custom React components (ModuleCard, GlossarySearch, PrerequisiteGraph) that integrate with Docusaurus theme?

**Decision:** Use Docusaurus Swizzling for theme components, standalone React components for custom features

**Rationale:**
- Swizzling allows customizing specific theme components (e.g., homepage) while preserving Docusaurus updates
- Standalone components (GlossarySearch, ModuleCard) can be developed independently and imported via MDX
- TypeScript support ensures type safety for component props

**Alternatives Considered:**
1. **Fork entire Docusaurus theme:** Rejected - loses upstream updates and security patches
2. **Use only MDX without React:** Rejected - cannot achieve interactive features like glossary search
3. **Build custom Next.js site:** Rejected - requires reimplementing all documentation features

**Implementation Guidance:**
```typescript
// src/pages/index.tsx - Custom homepage
import React from 'react';
import Layout from '@theme/Layout';
import ModuleCard from '@site/src/components/ModuleCard';

export default function Home(): JSX.Element {
  return (
    <Layout>
      <main>
        <section className="module-cards">
          <ModuleCard
            moduleNumber={1}
            title="ROS 2 Fundamentals"
            weekRange="Weeks 3-5"
            learningOutcomes={[...]}
            estimatedHours={30}
            link="/docs/module-1-ros2"
          />
        </section>
      </main>
    </Layout>
  );
}
```

**References:**
- [Docusaurus Swizzling Guide](https://docusaurus.io/docs/swizzling)
- [Creating Custom Pages](https://docusaurus.io/docs/creating-pages)
- [MDX and React Components](https://docusaurus.io/docs/markdown-features/react)

---

### 3. Metadata Schema Validation

**Question:** How to validate custom frontmatter metadata (week, module, prerequisites, learning_objectives) at build time?

**Decision:** Create custom Docusaurus plugin using `@docusaurus/core` lifecycle hooks

**Rationale:**
- Docusaurus plugins can hook into build process to validate content before deployment
- `contentLoaded` lifecycle hook provides access to all document metadata
- Validation failures can fail the build, preventing broken prerequisites from reaching production

**Alternatives Considered:**
1. **Pre-commit hook validation:** Rejected - doesn't catch issues until commit time, no CI enforcement
2. **Separate script run manually:** Rejected - easy to forget, not enforceable
3. **JSON Schema validation:** Considered but plugin approach provides better error messages and integration

**Implementation Guidance:**
```javascript
// plugins/validate-metadata/index.js
module.exports = function (context, options) {
  return {
    name: 'validate-metadata-plugin',
    async contentLoaded({content, actions}) {
      const {createData} = actions;
      const docs = content.loadedVersions[0].docs;

      docs.forEach(doc => {
        const {frontMatter} = doc;

        // Validate required fields
        if (!frontMatter.week || frontMatter.week < 1 || frontMatter.week > 13) {
          throw new Error(`Invalid week in ${doc.id}: must be 1-13`);
        }

        if (!frontMatter.module || frontMatter.module < 1 || frontMatter.module > 4) {
          throw new Error(`Invalid module in ${doc.id}: must be 1-4`);
        }

        // Validate prerequisites exist
        if (frontMatter.prerequisites) {
          frontMatter.prerequisites.forEach(prereq => {
            const prereqExists = docs.some(d => d.id === prereq);
            if (!prereqExists) {
              throw new Error(`Missing prerequisite ${prereq} in ${doc.id}`);
            }
          });
        }
      });
    },
  };
};
```

**References:**
- [Docusaurus Plugin Lifecycle API](https://docusaurus.io/docs/api/plugin-methods/lifecycle-apis)
- [Frontmatter Validation Example](https://github.com/facebook/docusaurus/discussions/5470)

---

### 4. Hybrid Search Implementation (Algolia + Custom Glossary)

**Question:** How to implement instant glossary search (<2s response) alongside Algolia DocSearch for main content?

**Decision:** Use local JSON data with Fuse.js for glossary search, Algolia for main content

**Rationale:**
- Local JSON with Fuse.js provides instant fuzzy matching (<100ms)
- Glossary data is static (100+ terms) and small enough to load locally (~50KB)
- Algolia DocSearch handles complex content indexing (chapter text, code snippets)
- Fuse.js is lightweight (12KB gzipped) and requires no external API calls

**Alternatives Considered:**
1. **Algolia for everything:** Rejected - glossary terms may not rank well, requires paid plan for custom ranking
2. **Lunr.js for local search:** Considered - but Fuse.js has better fuzzy matching for typo tolerance
3. **MeiliSearch self-hosted:** Rejected - unnecessary infrastructure for this use case

**Implementation Guidance:**
```typescript
// src/components/GlossarySearch.tsx
import React, {useState, useEffect} from 'react';
import Fuse from 'fuse.js';

const glossaryData = require('@site/static/data/glossary.json');

const fuse = new Fuse(glossaryData, {
  keys: ['term', 'definition'],
  threshold: 0.3,  // Fuzzy matching tolerance
  includeMatches: true,
});

export default function GlossarySearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    if (query.length > 2) {
      const searchResults = fuse.search(query);
      setResults(searchResults.slice(0, 5));  // Top 5 results
    } else {
      setResults([]);
    }
  }, [query]);

  return (
    <div className="glossary-search">
      <input
        type="text"
        placeholder="Search glossary..."
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      {results.length > 0 && (
        <ul className="results">
          {results.map(result => (
            <li key={result.item.term}>
              <strong>{result.item.term}</strong>
              <p>{result.item.definition}</p>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

**Glossary Data Format:**
```json
// static/data/glossary.json
[
  {
    "term": "ROS 2",
    "definition": "Robot Operating System 2, a set of software libraries and tools for building robot applications",
    "relatedChapters": ["module-1-ros2/week-3-basics/ros2-fundamentals"]
  },
  {
    "term": "Isaac Sim",
    "definition": "NVIDIA's robotics simulation platform built on Omniverse",
    "relatedChapters": ["module-3-isaac/week-8-setup"]
  }
]
```

**References:**
- [Fuse.js Documentation](https://fusejs.io/)
- [Algolia DocSearch Setup Guide](https://docsearch.algolia.com/docs/what-is-docsearch)

---

### 5. Prerequisite Dependency Graph Visualization

**Question:** Best library for rendering interactive prerequisite dependency graphs in React?

**Decision:** Use React Flow for interactive node-based graphs

**Rationale:**
- React Flow is specifically designed for node-based UIs (better than D3.js for this use case)
- Provides built-in features: zoom, pan, node selection, custom node rendering
- Lightweight (core library ~50KB) and well-maintained
- TypeScript support out of the box
- Can auto-layout using dagre algorithm

**Alternatives Considered:**
1. **D3.js:** Powerful but requires more custom code for interactive features, steeper learning curve
2. **Cytoscape.js:** Feature-rich but heavier (~200KB), more complex API
3. **Mermaid.js:** Simple syntax but limited interactivity (static diagrams)
4. **Custom SVG rendering:** Rejected - reinventing the wheel, no interactivity

**Implementation Guidance:**
```typescript
// src/components/PrerequisiteGraph.tsx
import React from 'react';
import ReactFlow, {Node, Edge, Position} from 'reactflow';
import dagre from 'dagre';
import 'reactflow/dist/style.css';

const createGraphLayout = (nodes, edges) => {
  const dagreGraph = new dagre.graphlib.Graph();
  dagreGraph.setDefaultEdgeLabel(() => ({}));
  dagreGraph.setGraph({rankdir: 'LR'});  // Left to right layout

  nodes.forEach(node => {
    dagreGraph.setNode(node.id, {width: 150, height: 50});
  });

  edges.forEach(edge => {
    dagreGraph.setEdge(edge.source, edge.target);
  });

  dagre.layout(dagreGraph);

  return nodes.map(node => {
    const nodeWithPosition = dagreGraph.node(node.id);
    return {
      ...node,
      position: {x: nodeWithPosition.x, y: nodeWithPosition.y},
    };
  });
};

export default function PrerequisiteGraph({chapters}) {
  // Convert chapters to nodes and edges
  const nodes = chapters.map(chapter => ({
    id: chapter.id,
    data: {label: chapter.title},
    position: {x: 0, y: 0},  // Will be set by layout
  }));

  const edges = chapters.flatMap(chapter =>
    chapter.prerequisites.map(prereq => ({
      id: `${prereq}-${chapter.id}`,
      source: prereq,
      target: chapter.id,
    }))
  );

  const layoutedNodes = createGraphLayout(nodes, edges);

  return (
    <div style={{height: '500px'}}>
      <ReactFlow nodes={layoutedNodes} edges={edges} fitView>
        {/* Add controls, minimap if needed */}
      </ReactFlow>
    </div>
  );
}
```

**References:**
- [React Flow Documentation](https://reactflow.dev/docs/introduction/)
- [Dagre Layout Algorithm](https://github.com/dagrejs/dagre)
- [React Flow Examples](https://reactflow.dev/examples)

---

### 6. Incremental Content Delivery Strategy

**Question:** How to support publishing Week 1-2 content independently while maintaining links to future content?

**Decision:** Use Docusaurus draft mode and conditional rendering for unreleased content

**Rationale:**
- Draft mode (`draft: true` in frontmatter) hides chapters from production build
- Can use custom plugin to check if linked content is draft and render placeholder
- Allows authoring all content in repository while controlling what's published
- Supports phased rollout: Introduction → Module 1 → Module 2 → etc.

**Alternatives Considered:**
1. **Separate branches for each phase:** Rejected - merge conflicts, harder to maintain consistency
2. **Separate repositories:** Rejected - loses prerequisite validation across modules
3. **Manual file deletion before build:** Rejected - error-prone, no version control

**Implementation Guidance:**
```markdown
---
title: "Week 3: ROS 2 Basics"
sidebar_label: "Week 3"
draft: true  # Not yet published
---
```

```javascript
// Custom plugin to handle draft links
module.exports = function (context, options) {
  return {
    name: 'draft-link-handler',
    async contentLoaded({content, actions}) {
      const docs = content.loadedVersions[0].docs;

      docs.forEach(doc => {
        const {frontMatter} = doc;

        // Check if prerequisites are drafts
        if (frontMatter.prerequisites) {
          frontMatter.prerequisites.forEach(prereq => {
            const prereqDoc = docs.find(d => d.id === prereq);
            if (prereqDoc?.frontMatter.draft) {
              console.warn(`${doc.id} references draft prerequisite: ${prereq}`);
              // Could inject placeholder component in production
            }
          });
        }
      });
    },
  };
};
```

**References:**
- [Docusaurus Draft Mode](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-docs#draft)
- [Conditional Rendering in MDX](https://docusaurus.io/docs/markdown-features/react#conditional-rendering)

---

### 7. Build Performance Optimization

**Question:** How to ensure fast builds (<3 minutes) and deployment with 40-50 markdown files and custom components?

**Decision:** Use Docusaurus built-in optimization features + lazy loading for heavy components

**Rationale:**
- Docusaurus v3 has built-in code splitting and lazy loading
- React Suspense for lazy loading prerequisite graph (only loads when viewed)
- Image optimization with `@docusaurus/plugin-ideal-image`
- Parallel builds with `--max-workers` flag

**Alternatives Considered:**
1. **Manual webpack configuration:** Rejected - Docusaurus handles this well by default
2. **Pre-build markdown processing:** Considered but unnecessary, Docusaurus is fast enough
3. **CDN for static assets:** Will use but not required for build speed

**Implementation Guidance:**
```javascript
// docusaurus.config.js
module.exports = {
  plugins: [
    '@docusaurus/plugin-ideal-image',  // Optimizes images
  ],
  themeConfig: {
    image: 'img/docusaurus-social-card.jpg',
  },
};
```

```typescript
// Lazy load heavy components
import React, {lazy, Suspense} from 'react';

const PrerequisiteGraph = lazy(() => import('@site/src/components/PrerequisiteGraph'));

export default function ChapterWithGraph() {
  return (
    <Suspense fallback={<div>Loading graph...</div>}>
      <PrerequisiteGraph chapters={chapters} />
    </Suspense>
  );
}
```

**Build Optimization:**
```json
// package.json
{
  "scripts": {
    "build": "docusaurus build --max-workers 4",
    "build:fast": "docusaurus build --max-workers 4 --minify false"
  }
}
```

**References:**
- [Docusaurus Build Performance](https://docusaurus.io/docs/deployment#build-performance)
- [Plugin Ideal Image](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-ideal-image)

---

## Summary of Key Decisions

| Topic | Decision | Rationale |
|-------|----------|-----------|
| **Sidebar Structure** | Nested categories with auto-collapse | Balances navigation usability with 40-50 pages |
| **Custom Components** | Swizzling + standalone React components | Preserves upstream updates while adding custom features |
| **Metadata Validation** | Custom Docusaurus plugin | Enforces schema at build time, fails on invalid data |
| **Search** | Hybrid: Algolia (content) + Fuse.js (glossary) | Instant glossary search + powerful content search |
| **Graph Visualization** | React Flow with dagre layout | Interactive, lightweight, TypeScript support |
| **Incremental Delivery** | Draft mode + conditional rendering | Phased rollout without separate branches |
| **Build Performance** | Built-in optimization + lazy loading | Fast builds (<3 min) without custom webpack config |

## Open Questions

1. **Algolia DocSearch Account Setup**
   - **Question:** Who owns the Algolia account and crawler configuration?
   - **Status:** Deferred to deployment phase (not blocking for structure implementation)
   - **Recommendation:** Use Algolia's open-source tier (free for public documentation)

2. **Glossary Term Compilation**
   - **Question:** Who authors the 100+ glossary terms and when?
   - **Status:** Deferred to content authoring phase (can be done incrementally)
   - **Recommendation:** Create glossary template and assign to domain experts per module

3. **Mobile Navigation UX**
   - **Question:** How to handle 40+ item sidebar on mobile (375px width)?
   - **Status:** Requires UX testing with prototype
   - **Recommendation:** Consider "By Module" tabs on mobile instead of full nested sidebar

## Next Steps

1. **Phase 1: Data Model & Contracts**
   - Define metadata schema in TypeScript interfaces
   - Create glossary.json contract
   - Document component prop interfaces

2. **Phase 1: Agent Context Update**
   - Update CLAUDE.md with Docusaurus v3 context
   - Add React Flow and Fuse.js to known libraries

3. **Phase 2: Implementation**
   - Scaffold Docusaurus project
   - Implement custom components
   - Create directory structure and templates

---

**Research Completed:** 2025-12-09
**Next Action:** Create `data-model.md` and `/contracts/` specifications
